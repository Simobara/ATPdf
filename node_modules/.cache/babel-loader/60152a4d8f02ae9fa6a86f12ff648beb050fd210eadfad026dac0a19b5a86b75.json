{"ast":null,"code":"import { Paragraph, TextRun, ImageRun, Header, Footer } from 'docx';\n// import { parsePhoneNumberFromString } from 'libphonenumber-js';\n\nimport ATLogoUp from '../../../../../../Assets/ATLogoUp.png';\nimport ATLogoDown from '../../../../../../Assets/ATLogoDown.png';\n\n// <---------------------------------------------------------------->GET LOGO UP / LOGO DOWN\nexport async function getLogoUp() {\n  const imageParagraph = new Paragraph({\n    alignment: \"right\",\n    children: [new ImageRun({\n      data: await (await fetch(ATLogoUp)).arrayBuffer(),\n      //Il primo await: Questo attende che la funzione fetch(ATLogoDown) sia completata. La funzione fetch restituisce una Promise che risolve con l'oggetto Response una volta che la richiesta HTTP è completata. Quindi, await fetch(ATLogoDown) restituirà un oggetto Response.\n      //Il secondo await: Dopo aver ottenuto l'oggetto Response, si chiama il metodo arrayBuffer() su di esso per ottenere i dati binari della risposta sotto forma di ArrayBuffer. Anche il metodo arrayBuffer() restituisce una Promise, che è il motivo per cui ce bisogno di un altro await per risolverla.\n      transformation: {\n        width: 250,\n        height: 100\n      }\n    })]\n  });\n  return new Header({\n    children: [imageParagraph]\n  });\n}\nexport async function getLogoDown() {\n  const imageParagraph = new Paragraph({\n    alignment: \"left\",\n    children: [new ImageRun({\n      data: await (await fetch(ATLogoDown)).arrayBuffer(),\n      transformation: {\n        width: 250,\n        height: 100\n      }\n    })]\n  });\n  return new Footer({\n    children: [imageParagraph]\n  });\n}\n\n// ------------------------------------------------------------------\n\nexport const getEta = async () => {\n  return new Paragraph({\n    alignment: \"left\",\n    children: [new TextRun(`Età: 30`)]\n  });\n};\nexport const getOccupazione = async () => {\n  return new Paragraph({\n    alignment: \"left\",\n    children: [new TextRun(`Occupazione: Ingegnere`)]\n  });\n};","map":{"version":3,"names":["Paragraph","TextRun","ImageRun","Header","Footer","ATLogoUp","ATLogoDown","getLogoUp","imageParagraph","alignment","children","data","fetch","arrayBuffer","transformation","width","height","getLogoDown","getEta","getOccupazione"],"sources":["/Users/momimac/Desktop/ATPdf/src/Components/PdfDropZone/PdfViewer/FCreateDoc/FParagraphs/0FGets/fGets.jsx"],"sourcesContent":["\nimport { Paragraph, TextRun, ImageRun, Header, Footer } from 'docx';\n// import { parsePhoneNumberFromString } from 'libphonenumber-js';\n\nimport ATLogoUp from '../../../../../../Assets/ATLogoUp.png';\nimport ATLogoDown from '../../../../../../Assets/ATLogoDown.png';\n\n// <---------------------------------------------------------------->GET LOGO UP / LOGO DOWN\nexport async function getLogoUp() {\n    const imageParagraph = new Paragraph({\n        alignment: \"right\",\n        children: [\n            new ImageRun({\n                data: await (await fetch(ATLogoUp)).arrayBuffer(),\n                //Il primo await: Questo attende che la funzione fetch(ATLogoDown) sia completata. La funzione fetch restituisce una Promise che risolve con l'oggetto Response una volta che la richiesta HTTP è completata. Quindi, await fetch(ATLogoDown) restituirà un oggetto Response.\n                //Il secondo await: Dopo aver ottenuto l'oggetto Response, si chiama il metodo arrayBuffer() su di esso per ottenere i dati binari della risposta sotto forma di ArrayBuffer. Anche il metodo arrayBuffer() restituisce una Promise, che è il motivo per cui ce bisogno di un altro await per risolverla.\n                transformation: { width: 250, height: 100 }\n            })\n        ]\n    });\n    return new Header({ children: [imageParagraph] });\n}\n\nexport async function getLogoDown() {\n    const imageParagraph = new Paragraph({\n        alignment: \"left\",\n        children: [\n            new ImageRun({\n                data: await (await fetch(ATLogoDown)).arrayBuffer(),\n                transformation: { width: 250, height: 100 }\n            })\n        ]\n    });\n    return new Footer({ children: [imageParagraph] });\n}\n\n// ------------------------------------------------------------------\n\n\n\n\nexport const getEta = async () => {\n    return new Paragraph({\n        alignment: \"left\",\n        children: [\n            new TextRun(`Età: 30`)\n        ]\n    });\n}\n\nexport const getOccupazione = async () => {\n    return new Paragraph({\n        alignment: \"left\",\n        children: [\n            new TextRun(`Occupazione: Ingegnere`)\n        ]\n    });\n}\n"],"mappings":"AACA,SAASA,SAAS,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,MAAM,QAAQ,MAAM;AACnE;;AAEA,OAAOC,QAAQ,MAAM,uCAAuC;AAC5D,OAAOC,UAAU,MAAM,yCAAyC;;AAEhE;AACA,OAAO,eAAeC,SAASA,CAAA,EAAG;EAC9B,MAAMC,cAAc,GAAG,IAAIR,SAAS,CAAC;IACjCS,SAAS,EAAE,OAAO;IAClBC,QAAQ,EAAE,CACN,IAAIR,QAAQ,CAAC;MACTS,IAAI,EAAE,MAAM,CAAC,MAAMC,KAAK,CAACP,QAAQ,CAAC,EAAEQ,WAAW,CAAC,CAAC;MACjD;MACA;MACAC,cAAc,EAAE;QAAEC,KAAK,EAAE,GAAG;QAAEC,MAAM,EAAE;MAAI;IAC9C,CAAC,CAAC;EAEV,CAAC,CAAC;EACF,OAAO,IAAIb,MAAM,CAAC;IAAEO,QAAQ,EAAE,CAACF,cAAc;EAAE,CAAC,CAAC;AACrD;AAEA,OAAO,eAAeS,WAAWA,CAAA,EAAG;EAChC,MAAMT,cAAc,GAAG,IAAIR,SAAS,CAAC;IACjCS,SAAS,EAAE,MAAM;IACjBC,QAAQ,EAAE,CACN,IAAIR,QAAQ,CAAC;MACTS,IAAI,EAAE,MAAM,CAAC,MAAMC,KAAK,CAACN,UAAU,CAAC,EAAEO,WAAW,CAAC,CAAC;MACnDC,cAAc,EAAE;QAAEC,KAAK,EAAE,GAAG;QAAEC,MAAM,EAAE;MAAI;IAC9C,CAAC,CAAC;EAEV,CAAC,CAAC;EACF,OAAO,IAAIZ,MAAM,CAAC;IAAEM,QAAQ,EAAE,CAACF,cAAc;EAAE,CAAC,CAAC;AACrD;;AAEA;;AAKA,OAAO,MAAMU,MAAM,GAAG,MAAAA,CAAA,KAAY;EAC9B,OAAO,IAAIlB,SAAS,CAAC;IACjBS,SAAS,EAAE,MAAM;IACjBC,QAAQ,EAAE,CACN,IAAIT,OAAO,CAAE,SAAQ,CAAC;EAE9B,CAAC,CAAC;AACN,CAAC;AAED,OAAO,MAAMkB,cAAc,GAAG,MAAAA,CAAA,KAAY;EACtC,OAAO,IAAInB,SAAS,CAAC;IACjBS,SAAS,EAAE,MAAM;IACjBC,QAAQ,EAAE,CACN,IAAIT,OAAO,CAAE,wBAAuB,CAAC;EAE7C,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}