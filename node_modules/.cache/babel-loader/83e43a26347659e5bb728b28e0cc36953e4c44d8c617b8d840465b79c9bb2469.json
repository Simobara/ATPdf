{"ast":null,"code":"import { Paragraph, TextRun } from 'docx';\nimport { nomiMaschili } from './NomiMaschili/nomiMaschili';\nimport { nomiFemminili } from './NomiFemminili/nomiFemminili';\nimport nlp from 'compromise';\nfunction analyzeTextWithNER(text) {\n  const doc = nlp(text);\n  return doc.people().out('array');\n}\nfunction isKnownName(name) {\n  const allNames = [...nomiMaschili, ...nomiFemminili];\n  return allNames.includes(name);\n}\nexport const getNome = async text => {\n  // Utilizza NER per riconoscere i nomi\n  const nerNames = analyzeTextWithNER(text);\n\n  // Filtra i nomi NER utilizzando l'elenco di nomi noti\n  const validNames = nerNames.filter(name => {\n    const nameParts = name.split(' ').map(part => part.trim());\n    return nameParts.some(isKnownName);\n  });\n\n  // Estrai nome e cognome\n  let nome = \"\";\n  let cognome = \"\";\n  for (const name of validNames) {\n    const parts = name.split(' ');\n    if (parts.length >= 2) {\n      if (isKnownName(parts[0])) {\n        nome = parts[0];\n        cognome = parts[1];\n      } else if (isKnownName(parts[1])) {\n        nome = parts[1];\n        cognome = parts[0];\n      }\n    }\n    // Se abbiamo trovato sia nome che cognome, possiamo interrompere il ciclo\n    if (nome && cognome) break;\n  }\n\n  // Costruzione del paragrafo finale\n  let finalText = `Nome: ${nome || \"Non trovato\"}, ${cognome || \"Non trovato\"}`;\n  return new Paragraph({\n    alignment: \"left\",\n    children: [new TextRun(finalText)]\n  });\n};","map":{"version":3,"names":["Paragraph","TextRun","nomiMaschili","nomiFemminili","nlp","analyzeTextWithNER","text","doc","people","out","isKnownName","name","allNames","includes","getNome","nerNames","validNames","filter","nameParts","split","map","part","trim","some","nome","cognome","parts","length","finalText","alignment","children"],"sources":["/Users/momimac/Desktop/ATPdf/src/Components/PdfDropZone/PdfViewer/FCreateDoc/FParagraphs/1FPersonaInf/1FGetNome/fGetNome.jsx"],"sourcesContent":["import { Paragraph, TextRun } from 'docx';\nimport { nomiMaschili } from './NomiMaschili/nomiMaschili';\nimport { nomiFemminili } from './NomiFemminili/nomiFemminili';\nimport nlp from 'compromise';\n\nfunction analyzeTextWithNER(text) {\n    const doc = nlp(text);\n    return doc.people().out('array');\n}\n\nfunction isKnownName(name) {\n    const allNames = [...nomiMaschili, ...nomiFemminili];\n    return allNames.includes(name);\n}\n\nexport const getNome = async (text) => {\n    // Utilizza NER per riconoscere i nomi\n    const nerNames = analyzeTextWithNER(text);\n\n    // Filtra i nomi NER utilizzando l'elenco di nomi noti\n    const validNames = nerNames.filter(name => {\n        const nameParts = name.split(' ').map(part => part.trim());\n        return nameParts.some(isKnownName);\n    });\n\n    // Estrai nome e cognome\n    let nome = \"\";\n    let cognome = \"\";\n\n    for (const name of validNames) {\n        const parts = name.split(' ');\n        if (parts.length >= 2) {\n            if (isKnownName(parts[0])) {\n                nome = parts[0];\n                cognome = parts[1];\n            } else if (isKnownName(parts[1])) {\n                nome = parts[1];\n                cognome = parts[0];\n            }\n        }\n        // Se abbiamo trovato sia nome che cognome, possiamo interrompere il ciclo\n        if (nome && cognome) break;\n    }\n\n    // Costruzione del paragrafo finale\n    let finalText = `Nome: ${nome || \"Non trovato\"}, ${cognome || \"Non trovato\"}`;\n\n    return new Paragraph({\n        alignment: \"left\",\n        children: [\n            new TextRun(finalText)\n        ]\n    });\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,QAAQ,MAAM;AACzC,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,aAAa,QAAQ,+BAA+B;AAC7D,OAAOC,GAAG,MAAM,YAAY;AAE5B,SAASC,kBAAkBA,CAACC,IAAI,EAAE;EAC9B,MAAMC,GAAG,GAAGH,GAAG,CAACE,IAAI,CAAC;EACrB,OAAOC,GAAG,CAACC,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,OAAO,CAAC;AACpC;AAEA,SAASC,WAAWA,CAACC,IAAI,EAAE;EACvB,MAAMC,QAAQ,GAAG,CAAC,GAAGV,YAAY,EAAE,GAAGC,aAAa,CAAC;EACpD,OAAOS,QAAQ,CAACC,QAAQ,CAACF,IAAI,CAAC;AAClC;AAEA,OAAO,MAAMG,OAAO,GAAG,MAAOR,IAAI,IAAK;EACnC;EACA,MAAMS,QAAQ,GAAGV,kBAAkB,CAACC,IAAI,CAAC;;EAEzC;EACA,MAAMU,UAAU,GAAGD,QAAQ,CAACE,MAAM,CAACN,IAAI,IAAI;IACvC,MAAMO,SAAS,GAAGP,IAAI,CAACQ,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAC1D,OAAOJ,SAAS,CAACK,IAAI,CAACb,WAAW,CAAC;EACtC,CAAC,CAAC;;EAEF;EACA,IAAIc,IAAI,GAAG,EAAE;EACb,IAAIC,OAAO,GAAG,EAAE;EAEhB,KAAK,MAAMd,IAAI,IAAIK,UAAU,EAAE;IAC3B,MAAMU,KAAK,GAAGf,IAAI,CAACQ,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAIO,KAAK,CAACC,MAAM,IAAI,CAAC,EAAE;MACnB,IAAIjB,WAAW,CAACgB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;QACvBF,IAAI,GAAGE,KAAK,CAAC,CAAC,CAAC;QACfD,OAAO,GAAGC,KAAK,CAAC,CAAC,CAAC;MACtB,CAAC,MAAM,IAAIhB,WAAW,CAACgB,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;QAC9BF,IAAI,GAAGE,KAAK,CAAC,CAAC,CAAC;QACfD,OAAO,GAAGC,KAAK,CAAC,CAAC,CAAC;MACtB;IACJ;IACA;IACA,IAAIF,IAAI,IAAIC,OAAO,EAAE;EACzB;;EAEA;EACA,IAAIG,SAAS,GAAI,SAAQJ,IAAI,IAAI,aAAc,KAAIC,OAAO,IAAI,aAAc,EAAC;EAE7E,OAAO,IAAIzB,SAAS,CAAC;IACjB6B,SAAS,EAAE,MAAM;IACjBC,QAAQ,EAAE,CACN,IAAI7B,OAAO,CAAC2B,SAAS,CAAC;EAE9B,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}