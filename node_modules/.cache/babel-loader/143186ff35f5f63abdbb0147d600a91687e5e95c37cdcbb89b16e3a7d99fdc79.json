{"ast":null,"code":"import { Paragraph, TextRun } from 'docx';\nimport nlp from 'compromise';\nconst keywords = [\"città\", \"residenza\", \"località\", \"vivo a\", \"situato a\", \"ubicato a\", \"residente a\"];\nconst extractLocalitaWithNLP = text => {\n  let foundLocalita = null;\n  for (let keyword of keywords) {\n    if (nlp(text).match(keyword).found) {\n      const sentences = nlp(text).sentences().out('array');\n      for (let sentence of sentences) {\n        if (sentence.includes(keyword)) {\n          const words = sentence.split(' '); // Estrae la parola successiva alla parola chiave come possibile località.\n          const keywordIndex = words.indexOf(keyword);\n          if (keywordIndex !== -1 && keywordIndex + 1 < words.length) {\n            foundLocalita = words[keywordIndex + 1];\n            break;\n          }\n        }\n      }\n    }\n    if (foundLocalita) break;\n  }\n  return foundLocalita;\n};\nconst extractLocalita = origText => {\n  for (let keyword of keywords) {\n    const regex = new RegExp(`\\\\b${keyword}\\\\b\\\\s+(\\\\w+(?:\\\\s+\\\\w+){0,4})`, \"i\"); //parola chiave seguita da 1-5 parole\n    const match = origText.match(regex);\n    if (match && match[1]) {\n      const possibleLocalita = match[1].split(' ')[0]; // Prendi la prima parola dopo la parola chiave come possibile località\n      return possibleLocalita;\n    }\n  }\n  return null;\n};\nexport const getLoc = async origText => {\n  let localita = await extractLocalita(origText);\n  if (!localita) {\n    localita = extractLocalitaWithNLP(origText);\n  }\n  return new Paragraph({\n    alignment: \"left\",\n    children: [new TextRun(`Localita: ${localita ? localita : \" / \"}`)]\n  });\n};","map":{"version":3,"names":["Paragraph","TextRun","nlp","keywords","extractLocalitaWithNLP","text","foundLocalita","keyword","match","found","sentences","out","sentence","includes","words","split","keywordIndex","indexOf","length","extractLocalita","origText","regex","RegExp","possibleLocalita","getLoc","localita","alignment","children"],"sources":["/Users/momimac/Desktop/ATPdf/src/Components/PdfDropZone/PdfViewer/FCreateDoc/FParagraphs/1PersonaInf/4GetLocalita/getLocalita.jsx"],"sourcesContent":["import { Paragraph, TextRun } from 'docx';\nimport nlp from 'compromise';\n\nconst keywords = [\n    \"città\", \"residenza\", \"località\", \"vivo a\", \"situato a\", \"ubicato a\", \"residente a\"\n];\n\nconst extractLocalitaWithNLP = (text) => {\n    let foundLocalita = null;\n    for (let keyword of keywords) {\n        if (nlp(text).match(keyword).found) {\n            const sentences = nlp(text).sentences().out('array');\n            for (let sentence of sentences) {\n                if (sentence.includes(keyword)) {\n                    const words = sentence.split(' '); // Estrae la parola successiva alla parola chiave come possibile località.\n                    const keywordIndex = words.indexOf(keyword);\n                    if (keywordIndex !== -1 && keywordIndex + 1 < words.length) {\n                        foundLocalita = words[keywordIndex + 1];\n                        break;\n                    }\n                }\n            }\n        }\n        if (foundLocalita) break;\n    }\n    return foundLocalita;\n};\n\nconst extractLocalita = (origText) => {\n    for (let keyword of keywords) {\n        const regex = new RegExp(`\\\\b${keyword}\\\\b\\\\s+(\\\\w+(?:\\\\s+\\\\w+){0,4})`, \"i\");//parola chiave seguita da 1-5 parole\n        const match = origText.match(regex);\n        if (match && match[1]) {\n            const possibleLocalita = match[1].split(' ')[0];// Prendi la prima parola dopo la parola chiave come possibile località\n            return possibleLocalita;\n        }\n    }\n    return null;\n};\n\nexport const getLoc = async (origText) => {\n    let localita = await extractLocalita(origText);\n    if (!localita) {\n        localita = extractLocalitaWithNLP(origText);\n    }\n    return new Paragraph({\n        alignment: \"left\",\n        children: [\n            new TextRun(`Localita: ${localita ? localita : \" / \"}`)\n        ]\n    });\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,QAAQ,MAAM;AACzC,OAAOC,GAAG,MAAM,YAAY;AAE5B,MAAMC,QAAQ,GAAG,CACb,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,WAAW,EAAE,aAAa,CACtF;AAED,MAAMC,sBAAsB,GAAIC,IAAI,IAAK;EACrC,IAAIC,aAAa,GAAG,IAAI;EACxB,KAAK,IAAIC,OAAO,IAAIJ,QAAQ,EAAE;IAC1B,IAAID,GAAG,CAACG,IAAI,CAAC,CAACG,KAAK,CAACD,OAAO,CAAC,CAACE,KAAK,EAAE;MAChC,MAAMC,SAAS,GAAGR,GAAG,CAACG,IAAI,CAAC,CAACK,SAAS,CAAC,CAAC,CAACC,GAAG,CAAC,OAAO,CAAC;MACpD,KAAK,IAAIC,QAAQ,IAAIF,SAAS,EAAE;QAC5B,IAAIE,QAAQ,CAACC,QAAQ,CAACN,OAAO,CAAC,EAAE;UAC5B,MAAMO,KAAK,GAAGF,QAAQ,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;UACnC,MAAMC,YAAY,GAAGF,KAAK,CAACG,OAAO,CAACV,OAAO,CAAC;UAC3C,IAAIS,YAAY,KAAK,CAAC,CAAC,IAAIA,YAAY,GAAG,CAAC,GAAGF,KAAK,CAACI,MAAM,EAAE;YACxDZ,aAAa,GAAGQ,KAAK,CAACE,YAAY,GAAG,CAAC,CAAC;YACvC;UACJ;QACJ;MACJ;IACJ;IACA,IAAIV,aAAa,EAAE;EACvB;EACA,OAAOA,aAAa;AACxB,CAAC;AAED,MAAMa,eAAe,GAAIC,QAAQ,IAAK;EAClC,KAAK,IAAIb,OAAO,IAAIJ,QAAQ,EAAE;IAC1B,MAAMkB,KAAK,GAAG,IAAIC,MAAM,CAAE,MAAKf,OAAQ,gCAA+B,EAAE,GAAG,CAAC,CAAC;IAC7E,MAAMC,KAAK,GAAGY,QAAQ,CAACZ,KAAK,CAACa,KAAK,CAAC;IACnC,IAAIb,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;MACnB,MAAMe,gBAAgB,GAAGf,KAAK,CAAC,CAAC,CAAC,CAACO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MAChD,OAAOQ,gBAAgB;IAC3B;EACJ;EACA,OAAO,IAAI;AACf,CAAC;AAED,OAAO,MAAMC,MAAM,GAAG,MAAOJ,QAAQ,IAAK;EACtC,IAAIK,QAAQ,GAAG,MAAMN,eAAe,CAACC,QAAQ,CAAC;EAC9C,IAAI,CAACK,QAAQ,EAAE;IACXA,QAAQ,GAAGrB,sBAAsB,CAACgB,QAAQ,CAAC;EAC/C;EACA,OAAO,IAAIpB,SAAS,CAAC;IACjB0B,SAAS,EAAE,MAAM;IACjBC,QAAQ,EAAE,CACN,IAAI1B,OAAO,CAAE,aAAYwB,QAAQ,GAAGA,QAAQ,GAAG,KAAM,EAAC,CAAC;EAE/D,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}